import json
from collections import OrderedDict
from pathlib import Path
from typing import Any, Dict, Type, cast

import datamodel_code_generator
from pydantic import BaseModel
from pydantic.alias_generators import to_snake
from pydantic.json_schema import GenerateJsonSchema

from event_model.basemodels import ALL_BASEMODELS

JSONSCHEMA = Path(__file__).parent.parent / "schemas"
TYPEDDICTS = Path(__file__).parent.parent / "documents"
TEMPLATES = Path(__file__).parent / "templates"


class SnakeCaseTitleField(GenerateJsonSchema):
    def generate(self, schema, mode="validation"):
        jsonschema = super().generate(schema, mode=mode)
        jsonschema["title"] = to_snake(jsonschema["title"])

        for key, property in jsonschema.get("properties", {}).items():
            property["title"] = to_snake(key)
        for definition in jsonschema.get("$defs", {}).values():
            definition["title"] = to_snake(definition["title"])
            for key, property in definition.get("properties", {}).items():
                property["title"] = to_snake(key)
        return jsonschema


def snake_to_title(snake: str) -> str:
    return snake.title().replace("_", "")


# Used to add user written schema to autogenerated schema.
def merge_dicts(dict1: dict, dict2: dict) -> dict:
    return_dict = dict2.copy()

    for key in dict1:
        if key not in dict2:
            return_dict[key] = dict1[key]

        elif not isinstance(dict1[key], type(dict2[key])):
            return_dict[key] = dict1[key]

        elif isinstance(dict1[key], dict):
            return_dict[key] = merge_dicts(dict1[key], dict2[key])

        elif isinstance(dict1[key], list):
            return_dict[key] = dict1[key] + dict2[key]

    return return_dict


def sort_alphabetically(schema: Dict) -> Dict:
    """Sorts the schema alphabetically by key name, exchanging the
    properties dicts for OrderedDicts"""
    schema = OrderedDict(sorted(schema.items(), key=lambda x: x[0]))

    return schema


SortOrder = {
    "title": 0,
    "description": 1,
    "type": 2,
    "allOf": 3,
    "$defs": 4,
    "properties": 5,
    "required": 6,
    "patternProperties": 7,
    "additionalProperties": 8,
    "unevaluatedProperties": 9,
}


def sort_schema(document_schema: Dict[str, Any]) -> Dict[str, Any]:
    assert isinstance(document_schema, dict)
    document_schema = OrderedDict(
        sorted(
            document_schema.items(),
            key=lambda x: SortOrder.get(x[0], len(SortOrder)),
        )
    )

    for key in document_schema:
        if key in ("$defs", "properties", "required"):
            if isinstance(document_schema[key], dict):
                document_schema[key] = sort_alphabetically(document_schema[key])
                for key2 in document_schema[key]:
                    if isinstance(document_schema[key][key2], dict):
                        document_schema[key][key2] = sort_schema(
                            document_schema[key][key2]
                        )
            elif isinstance(document_schema[key], list):
                document_schema[key].sort()

    return document_schema


def dump_json(schema: Dict[str, Any], jsonschema_path: Path):
    """Returns true if the basemodel had to change, false otherwise"""
    sorted_schema = sort_schema(schema)
    with jsonschema_path.open(mode="w") as f:
        json.dump(sorted_schema, f, indent=4)
        f.write("\n")
    return True


def generate_typeddict(jsonschema_path: Path, documents_root=TYPEDDICTS) -> Path:
    document_path = documents_root / f"{jsonschema_path.stem}.py"
    datamodel_code_generator.generate(
        input_=jsonschema_path,
        input_file_type=datamodel_code_generator.InputFileType.JsonSchema,
        output=document_path,
        output_model_type=datamodel_code_generator.DataModelType.TypingTypedDict,
        use_schema_description=True,
        use_field_description=True,
        use_annotated=True,
        field_constraints=True,
        wrap_string_literal=True,
        use_double_quotes=True,
        disable_timestamp=True,
        custom_template_dir=TEMPLATES,
    )
    with document_path.open("r+") as f:
        content = f.read()
        f.seek(0, 0)
        f.write("# ruff: noqa\n" + content)
    return document_path


def get_jsonschema_path(jsonschema: Dict, root=JSONSCHEMA) -> Path:
    return root / f"{to_snake(jsonschema['title'])}.json"


def _generate_jsonschema(
    basemodel: Type[BaseModel],
    jsonschema_root=JSONSCHEMA,
    is_parent: bool = False,
) -> Dict[str, Any]:
    refs = []

    for parent in [parent for parent in basemodel.__bases__ if parent is not BaseModel]:
        assert issubclass(
            parent, BaseModel
        )  # Parents of BaseModel's can only be other BaseModel
        parent_jsonschema = _generate_jsonschema(
            parent,
            jsonschema_root=jsonschema_root,
            is_parent=True,
        )
        refs.append(parent_jsonschema)

    schema_extra: Dict[str, Any] = cast(
        Dict[str, Any], basemodel.model_config.pop("json_schema_extra", {})
    )
    model_jsonschema = basemodel.model_json_schema(schema_generator=SnakeCaseTitleField)
    model_jsonschema = merge_dicts(model_jsonschema, schema_extra)

    additional_properties = (
        model_jsonschema.pop("additionalProperties", None)
        if is_parent or refs
        else None
    )

    if refs:
        if additional_properties is not None and not is_parent:
            model_jsonschema["unevaluatedProperties"] = additional_properties

        for ref in refs:
            for property in ref["properties"]:
                model_jsonschema["properties"].pop(property, None)
            if model_jsonschema.get("$defs", None) is None:
                model_jsonschema["$defs"] = {}
            model_jsonschema["$defs"][snake_to_title(ref["title"])] = ref

            if model_jsonschema.get("required", None) is not None:
                for ref_property in ref["properties"]:
                    if ref_property in model_jsonschema["required"]:
                        model_jsonschema["required"].remove(ref_property)

        model_jsonschema["allOf"] = [
            {"$ref": f"#/$defs/{snake_to_title(ref['title'])}"} for ref in refs
        ]

    return model_jsonschema


def generate_jsonschema(
    basemodel: Type[BaseModel],
    jsonschema_root=JSONSCHEMA,
) -> Path:
    model_jsonschema = _generate_jsonschema(basemodel, jsonschema_root=jsonschema_root)
    jsonschema_path = get_jsonschema_path(model_jsonschema, root=jsonschema_root)
    dump_json(model_jsonschema, jsonschema_path)

    return jsonschema_path


GENERATED_INIT_PY = """# generated in `event_model/generate`

from typing import Tuple, Type, Union

{0}

{1}Type = Union[
{2}
]

{1} = Union[
{3}
]

ALL_{4}: Tuple[{1}Type, ...] = (
{5}
)"""


def generate_init_py(output_root: Path):
    document_names = sorted(
        [
            file.stem
            for file in output_root.iterdir()
            if file.stem != "__init__" and file.suffix == ".py"
        ]
    )

    document_class_names = [
        f"{snake_to_title(document_name)}" for document_name in document_names
    ]

    init_py_imports = "\n".join(
        sorted(
            [
                f"from .{document_name} import *  # noqa: F403"
                for document_name in document_names
            ]
        )
    )

    document_types = "\n".join(
        [
            f"    Type[{class_name}],  # noqa: F405,"
            for class_name in document_class_names
        ]
    )

    documents = "\n".join(
        [f"    {class_name},  # noqa: F405" for class_name in document_class_names]
    )

    all_documents = "\n".join(
        [f"    {class_name},  # noqa: F405" for class_name in document_class_names]
    )

    init_py = GENERATED_INIT_PY.format(
        init_py_imports,
        output_root.name.rstrip("s").title(),
        document_types,
        documents,
        output_root.name.upper(),
        all_documents,
    )

    with open(output_root / "__init__.py", "w") as f:
        f.write(init_py + "\n")


def generate(jsonschema_root: Path = JSONSCHEMA, documents_root: Path = TYPEDDICTS):
    for basemodel in ALL_BASEMODELS:
        generate_jsonschema(basemodel, jsonschema_root=jsonschema_root)
    for jsonschema_path in jsonschema_root.iterdir():
        if not jsonschema_path.name.startswith("bulk"):
            generate_typeddict(jsonschema_path, documents_root=documents_root)

    generate_init_py(documents_root)
