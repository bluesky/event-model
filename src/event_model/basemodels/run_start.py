# ruff: noqa
# type: ignore
# generated by datamodel-codegen:
#   filename:  run_start.json

from __future__ import annotations

from typing import Any, Dict, List, Literal, Optional, Union

from pydantic import BaseModel, ConfigDict, Field, RootModel


class Calculation(BaseModel):
    args: Optional[List] = Field(None, title="Args")
    callable: str = Field(..., title="Callable")
    """
    callable function to perform calculation
    """
    kwargs: Optional[Dict[str, Any]] = Field(None, title="Kwargs")
    """
    kwargs for calcalation callable
    """


import re

from pydantic import field_validator


class DataType(RootModel):
    root: Dict[str, Union["DataType", Any]] = Field(..., title="DataType")

    @field_validator("root")
    def validate_root(cls, value):
        if not isinstance(value, dict):
            value
        pattern = r"^([^./]+)$"
        for key, val in value.items():
            if not re.match(pattern, key):
                raise ValueError(f"Key '{key}' does not match pattern '{pattern}'")
            if isinstance(val, dict):
                value[key] = DataType(**val)
        return value


class Hints(BaseModel):
    """
    Start-level hints
    """

    dimensions: Optional[List[List[Union[List[str], str]]]] = Field(
        None, title="Dimensions"
    )
    """
    The independent axes of the experiment. Ordered slow to fast
    """


class CalculatedEventProjection(BaseModel):
    calculation: Calculation = Field(..., title="calculation properties")
    """
    required fields if type is calculated
    """
    field: str = Field(..., title="Field")
    location: Literal["event"] = Field(..., title="Location")
    """
    Projection comes and event
    """
    stream: str = Field(..., title="Stream")
    type: Literal["calculated"] = Field(..., title="Type")
    """
    Projection is of type calculated, a value that requires calculation.
    """


class ConfigurationProjection(BaseModel):
    config_device: str = Field(..., title="Config Device")
    config_index: int = Field(..., title="Config Index")
    field: str = Field(..., title="Field")
    location: Literal["configuration"] = Field(..., title="Location")
    """
    Projection comes from configuration fields in the event_descriptor document
    """
    stream: str = Field(..., title="Stream")
    type: Literal["linked"] = Field(..., title="Type")
    """
    Projection is of type linked, a value linked from the data set.
    """


class LinkedEventProjection(BaseModel):
    field: str = Field(..., title="Field")
    location: Literal["event"] = Field(..., title="Location")
    """
    Projection comes and event
    """
    stream: str = Field(..., title="Stream")
    type: Literal["linked"] = Field(..., title="Type")
    """
    Projection is of type linked, a value linked from the data set.
    """


class StaticProjection(BaseModel):
    type: Literal["static"] = Field(..., title="Type")
    """
    Projection is of type static, a value defined here in the projection
    """
    value: Any = Field(..., title="Value")
    """
    value explicitely defined in the static projection
    """


class Projections(BaseModel):
    """
    Describe how to interperet this run as the given projection
    """

    configuration: Dict[str, Any] = Field(..., title="Configuration")
    """
    Static information about projection
    """
    name: Optional[str] = Field(None, title="Name")
    """
    The name of the projection
    """
    projection: Dict[
        str,
        Union[
            ConfigurationProjection,
            LinkedEventProjection,
            CalculatedEventProjection,
            StaticProjection,
        ],
    ] = Field(..., title="Projection")
    additionalProperties: Optional[Any] = None
    version: str = Field(..., title="Version")
    """
    The version of the projection spec. Can specify the version of an external specification.
    """


from pydantic import model_validator


class RunStart(BaseModel):
    """
    Document created at the start of run. Provides a seach target and later documents link to it
    """

    model_config = ConfigDict(
        extra="allow",
    )

    @model_validator(mode="before")
    def store_extra_values_as_datatype(cls, values):
        extra_values = {k: v for k, v in values.items() if k not in cls.model_fields}
        pattern = r"^([^./]+)$"
        for key, value in extra_values.items():
            if not re.match(pattern, key):
                raise ValueError(f"Key '{key}' does not match pattern '{pattern}'")
            values[key] = DataType(value)
        return values

    data_groups: Optional[List[str]] = Field(None, title="Data Groups")
    """
    An optional list of data access groups that have meaning to some external system. Examples might include facility, beamline, end stations, proposal, safety form.
    """
    data_session: Optional[str] = Field(None, title="Data Session")
    """
    An optional field for grouping runs. The meaning is not mandated, but this is a data management grouping and not a scientific grouping. It is intended to group runs in a visit or set of trials.
    """
    data_type: Optional[DataType] = None
    group: Optional[str] = Field(None, title="Group")
    """
    Unix group to associate this data with
    """
    hints: Optional[Hints] = None
    owner: Optional[str] = Field(None, title="Owner")
    """
    Unix owner to associate this data with
    """
    project: Optional[str] = Field(None, title="Project")
    """
    Name of project that this run is part of
    """
    projections: Optional[List[Projections]] = Field(None, title="Projections")
    sample: Optional[Union[Dict[str, Any], str]] = Field(None, title="Sample")
    """
    Information about the sample, may be a UID to another collection
    """
    scan_id: Optional[int] = Field(None, title="Scan Id")
    """
    Scan ID number, not globally unique
    """
    time: float = Field(..., title="Time")
    """
    Time the run started.  Unix epoch time
    """
    uid: str = Field(..., title="Uid")
    """
    Globally unique ID for this run
    """


DataType.model_rebuild()
